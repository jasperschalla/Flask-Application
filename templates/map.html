<!DOCTYPE html>
<html>
<head>
    <!--Change viewport for mobile version-->
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <!--load css files of used packages-->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.0.3/dist/leaflet.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css"/>
    <!--load js files of used packages-->
    <script src="https://unpkg.com/leaflet@1.0.3/dist/leaflet.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.6/d3.min.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://code.jquery.com/ui/1.12.1/jquery-ui.js"></script>
    
    <!--css file of the map file-->
    <style>

        * {
           margin: 0; 
        }    

        html, body {
            position: relative;
            height: 100%;
            overflow: hidden;
        }
        
        h1, h2, h3, h4, p {
            color: white;
        }

        
        /* 1. Container for all the content */
        #main_container {
            display: flex;
            flex-direction: column;
            height: 100%;
        }
        
        /* 1.1 Container for the header */
        #map_header {
            display: flex;
            flex-direction: row;
            height: 12%;
            background-color: #252944;
            border-bottom: solid;
            border-color: #4B5256;
            border-width: 5px;
            justify-content: space-around;
            align-items: center;
        }
        
        /* Menu when window size is small */
        #mobile_menu {
            display: none;
            text-align: center;
        }
        
        /* Icon for the mobile menu */
        #mobile_menu > i {
            color: white;
            font-size: 20px;
            cursor: pointer;
            will-change: transform;
            transition: transform 1s;
        }
        
        /* Moves the icon when mobile menu is opened */
        i.mobile_menu_show {
            transform: rotate(90deg);
        }
        
        /* Menu bar for the mobile version */
        .mobile_menu_bar {
            position: absolute;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items:center;
            text-align: center;
            width: 100%;
            top: 80px;
            left: 0;
            background-color: white;
            z-index: 3;
            border-bottom: solid;
            border-color: #4B5256;
            border-bottom-width: 5px;
        }
        
        /* Style entries of the mobile menu */
        .mobile_menu_bar > a {
            width: 100%;
            text-decoration: none;
            color: #252944;
            padding-top: 10px;
            padding-bottom: 10px;
        }
        
        .mobile_menu_bar > a:hover {
            background-color: #4B5256;
            color: white;
        }
        
        /* Title of the application */
        #mid_header >h1 {
            padding-top: 10px; 
            padding-left: 20px;
        }
        
        /* Link to home file */
        #home_ref {
            font-size: 18px;
            color: white;
            text-decoration: none;
        }

        #home_ref:hover {
            color: #4B5256;
        }
        
        /* Link to Digital Earth home page */
        #de_logo {
            height: 55px;
            width: auto;
        }

        /* 1.2 Container for the leaflet map */
        #my-map {
            height: 90%;
            z-index: 0;
        }
        
        /* Info box at the right bottom of map */
        .leaflet-right .leaflet-control {
            margin-right: 420px;
            transition: margin-right 2s;
            will-change: margin-right;
        }
        
        .info {
            color: black;
            background-color: white;
            opacity: 0.8;
            width: 150px;
            height: 60px;
            padding: 10px;
            border-radius: 10px;
        }

        .info h4 {
            color: black;
        }
        
        /* legend box at the left bottom of map */
        .legend {
            display: flex;
            flex-direction: column;
            background-color: white;
            opacity: 0.8;
            line-height: 18px;
            color: #555;
            padding: 10px 20px 10px 10px;
            border-radius: 10px;
        }

        .legend i {
            width: 30px;
            height: 0.6px;
            float: left;
            margin-right: 8px;
        }

        .legend_element{
            color: #555;
        }

        /* 1.3 Controls for the leaflet map */
        .controls {
            position: absolute;
            top: 96px;
            right: 0;
            display: flex;
            flex-direction: row;
            background-color: #252944;
            height: 90%;
            width: 400px;
            transition: right 2s;
            will-change: right;
            z-index: 1;
        }
        
        /* Class moves user input when controls are hidden */
        .hide_controls {
            right: -330px;
        }
        
        /* 1.3.1 Container for the expand button */
        #button_container {
            flex-grow: 1;
            background-color: #4B5256;
        }
        
        /* Button to expand  */
        .expand_btn {
            margin: 10px 10px 20px 10px;
            height: 30px;
            width: 50px;
            border-radius: 5px;
            border-color: #4B5256;
            transition: right 2s; 
            will-change: right;
            cursor: pointer;
        }

        /* Class moves button when controls are hidden */
        .hide_expand_btn {
            right: 30px;
        }
        
        /* Class represents default position of button image  */
        .show_i {
            color: #4B5256; 
            transform: rotate(270deg);
            transition: transform 2s;
            will-change: transform;
        }

        /* Class rotates button image when controls are hidden */
        .hide_i {
            transform: rotate(90deg);
        }
        
        /* 1.3.2 Container for the user input */
        #input_container {
            flex-grow: 10;
            display: flex;
            flex-direction: column;
        }
        
        /* 1.3.2.1 Buttons to switch between inset and map option */
        #btn_group {
            position: relative;
            padding: 0px;
            margin: 10px;
        }
        
        /* Style of buttons */
        #btn_group button {
            background-color: #4B5256;
            color: white;
            float: left;
            cursor: pointer;
            width: 50%;
            height: 30px;
        }
        
        /* Button to switch to map option */
        #map_btn {
            opacity: 1;
            border-top-left-radius: 5px;
            border-bottom-left-radius: 5px;
        }

        /* Button to switch to inset option */
        #inset_btn {
            opacity: 0.5;
            border-top-right-radius: 5px;
            border-bottom-right-radius: 5px;
        }
        
        
        /* 1.3.2.2 Form with user input for map option */
        #form_post_map {
            display: flex;
            flex-direction: column;
            width: 320px;
            height: 100%;
            overflow-x: hidden;
            overflow-y: auto;
        }
        
        /* Class for user input labels */
        .input_label {
            color: white;
            margin-left: 20px;
        }
        
        /* Class for input fields */
        .inputs {
            margin: 10px 20px 20px 20px;
            color: white;
            background-color: #4B5256;
            border-radius: 5px;
            min-height: 25px;
            border: solid;
            border-color: white;
            border-width: 1px;
        }
        
        /* Container for output from value extraction */
        #value_output {
            margin: 0px 0px 10px 20px; 
            background-color: white;
            color: #555;
            width: 87%; 
            min-height: 25px; 
            border-radius: 5px;
            text-align: center;
            padding-top: 10px;
            font-weight: bold;
        }
        
        /* Class for submit button for both forms */
        .submit {
            width: 100px;
            cursor: pointer;
        }
        
        /* Animation checkbox when several bands are available */
        
        #animation_play {
            margin: -5px 20px 15px 20px;
            padding: 5px;
            background-color: #252944;
            display: none;
            text-align: center;
            border: solid;
            border-width: 1px;
            border-color: white;
            border-radius: 5px;
            cursor: pointer;
        }
        
        #animation_play:hover {
            background-color: #4B5256;
        }
        
        #download {
            margin: 10px 20px 15px 20px;
            padding: 5px;
            background-color: #252944;
            display: block;
            text-align: center;
            border: solid;
            border-width: 1px;
            border-color: white;
            border-radius: 5px;
            cursor: pointer;
        }
        
        #download:hover {
            background-color: #4B5256;
        }
        
        .animation_control {
            display: none;
            grid-template: 
                "progress progress progress"
                "previous play next"
                "time time replay"
                "time time replay";
            justify-content:space-between;
            position: absolute;
            padding-top: 1%;
            left: 25%;
            width: 25%;
            height: 15%;
            bottom: 5%;
            background-color: #252944;
            border-radius: 5px;
            transition: left 2s;
            will-change: left;
        }
        
        .animation_expand {
            left: 35%;
        }
        
        .previous {
            padding-left: 50px;
            
        }
        
        .next{
            padding-right: 50px;
        }
        
        #progress {
            grid-area: progress;
            margin-bottom: 10px;
            margin-left: 25px;
            margin-right: 25px;
            background-color: white;
            border-radius: 5px;
            height: 35%;
        }
        
        #bar {
            width: 0%;
            height: 100%;
            background-color: deepskyblue;
            border-radius: 5px;
        }
        
        .replay {
            margin-top: 10px;
        }
        
        #time {
            text-align: center;
            margin-left: 25px;
            margin-bottom: 20px;
            border-radius: 5px;
            background-color: #4B5256;
        }
        
        #time_input_map {
            display: none;
        }
        
        #time_input_map_label {
            display: none;
        }
        
        .download_control{
            position: absolute;
            top: 25%;
            left: 35%;
            background-color: #252944;
            width: 30%;
            height: 50%;
            display: flex;
            flex-direction: column;
            border-radius: 3px;
            border: solid;
            border-color: #4B5256;
            border-width: 5px;
            display: none;
            will-change: display;
            transition: 2s display;
            z-index: 3;
            padding-top: 5%;
        }
        
        .download_show {
            display: flex;
        }
        
        .download_dataset {
            margin-bottom: 5px;
            margin-top: 5px;
            margin-left: 5px;
            margin-right: 5px;
            display: flex;
            flex-direction: row;
            padding: 10px;
            padding-left: 50px;
            background-color: grey;
            color: white;
            border-radius: 5px;
            justify-content:flex-start;
        }
        
        .exit_bar {
            position: absolute;
            top: 25%;
            left: 35%;
            width: 30.5%;
            flex-direction: row;
            justify-content: space-around;
            height: 7%;
            background-color: #4B5256;
            margin-bottom: 15px;
            color: white;
            padding-top: 15px;
            display: none;
            will-change: display;
            transition: 2s display;
            z-index: 4;
        }
        
        .exit_bar > p {
            font-size: 20px;
            margin-left: 10%;
        }
        
        .exit_bar > i {
            font-size: 25px;
            height: 50%;
            cursor: pointer;
            padding-left: 20%;
        }
        
        .submit_download {
            margin-top: 25%;
            margin-bottom: 5px;
            width: 20%;
            height: 10%;
            border-radius: 5px;
            margin-left: 40%;
            background-color: #4B5256;
            color: white;
        }

        
        /* Container for expandable group select and color palette selection */
        div.selectBox {
            font-size: 15px;
            margin: 10px 20px 20px 20px;
            display: flex;
            text-align: left;
            flex-direction: row;
            cursor:default;
            clear:both;
            border: 1px solid white;
            border-radius: 5px;
        }
        
        /* Container for selected option */
        span.selected {
            padding-top: 5px;
            padding-left: 10px;
            flex-grow: 6;
            background:#4B5256;
            color: white;
            border-top-left-radius: 5px;
            border-bottom-left-radius: 5px;
        }
        
        /* Container for arrow */
        span.selectArrow {
            flex-grow: 1;
            text-align: center;
            line-height: 25px;
            color: white;
            background:#4B5256;
            border-top-right-radius: 5px;
            border-bottom-right-radius: 5px;
            font-size: 10px;
        }
        
        span.selectArrow,span.selected {
            z-index:2;
        }
        
        /* Container for grouped options */
        div.selectOptions {
            position:absolute;
            top:125px;
            border:1px solid #ccc;
            border-bottom-right-radius:5px;
            border-bottom-left-radius:5px;
            overflow:hidden;
            background:#4B5256;
            color: white;
            display:none;
        }

        /* Container for Group label and button  */
        .heading {
            display: flex; 
            flex-direction: row;
            font-size: 15px;
        }
        
        /* Group label */
        .groupOption {
            padding: 10px;
            width: 90%;
        }
        
        /* Group button */
        .selectBtn {
            width: 10%;
            padding-top: 10px;
            padding-left: 15px;
        }
        
        .selectBtn:hover {
            background-color: #4096ee;
        }
        
        /* Options to select from */
        .selectOption {
            padding: 5px;
            padding-left: 10px;
            background-color: darkgrey;
            display: none;
        }
        
        .selectOption:hover {
            background-color: #4096ee;
        }
        
        
        /* Container for selected palette */
        .selectedPalette {
            flex-grow: 6;
            background: #4B5256;
            display: flex;
            flex-direction: row;
            padding: 0 2px 0 2px;
            width: 100%;
            height: 100%;
            border-top-left-radius: 5px;
            border-bottom-left-radius: 5px;
        }
        
        /* Icons to represent selected palette */
        .selectedPalette > i {
            width: 1%;
            height: 100%;
        }
        
        /* Container for the palette options */
        #selectOptionsPalette {
            top: 428px;
        }
        
        /* Container for optional palettes */
        .selectOptionPalette {
            display: flex;
            flex-direction: row;
            background-color: transparent;
            margin: 2px 0 2px 0;
            padding: 0;
            width: 100%;
            height: 100%;
        }
        
        /* Icons to represent optional palettes */
        .selectOptionPalette > i {
            width: 1%;
            height: 20px;
        }
        
        .selectOptionPalette:hover {
            background-color: #4096ee;
            opacity: 0.5;
        }

        /* 1.3.2.3 Form with user input for inset option, classes from map input form used */
        #form_post_inset {
            display: flex;
            flex-direction: column;
            display: none;
            width: 320px;
            overflow-x: hidden;
            overflow-y: auto;
        }
        
        /* Inset for mobile version */
        #mobile_inset {
            display: none;
        }

        /* 1.4 Inset from inset option */
        .inset {
            position: absolute;
            left: 10%;
            top: 25%;
            width: 50%;
            height: 45%;
            background-color: #252944;
            z-index: -1;
            opacity: 0;
            border-radius: 10px;
            transition: left 2s,
                opacity 0s,
                z-index 0s;
            will-change: left,
                opacity,
                z-index;
        }
        
        /* Plotly plot */
        .js-plotly-plot {
            
        }
        
        /* Moves inset when controls are hidden */
        .inset_expand {
            left: 25%;
        }

        /* Moves inset when controls are shown */
        .inset_show {
            opacity: 1;
            z-index: 1;
        }
        
        /* Container for plotly plot */
        #plotly {
            margin: 20px;
        }

        /* 1.5 Container for toast error message */
        .toast {
            color: white;
            position: absolute;
            bottom: -100px;
            left: 25%;
            width: 50%;
            background-color: #252944;
            border-radius: 10px;
            opacity: 0;
            text-align: center;
            font-size: 20px;
            padding: 10px 20px 20px 20px;
            z-index: 3;
            border: solid;
            border-color: #4B5256;
            border-width: 5px;
        }

        /* Move and show toast message when error occurs */
        .toast_show {
            animation: fadeinout 5s ease-in-out;
            -webkit-animation: fadeinout 5s ease-in-out;
        }
        
        /* Animations for the popup of the toast message */
        @keyframes fadeinout {
          0% {bottom: -100px; opacity: 0;}
          30% {bottom: 100px; opacity: 1;}
          80% {bottom: 100px; opacity: 1;}
          100% {bottom: -100px; opacity: 0;}
        }

         @-webkit-keyframes fadeinout {
          0% {bottom: -100px; opacity: 0;}
          30% {bottom: 100px; opacity: 1;}
          80% {bottom: 100px; opacity: 1;}
          100% {bottom: -100px; opacity: 0;}
        }
        
        /* 1.6 Container for loading icon */
        .loader {
          position: absolute;
          top: 520px;
          left: 18px;
          border: 8px solid white;
          border-radius: 50%;
          border-top: 8px solid #252944;
          border-width: 5px;
          width: 20px;
          height: 20px;
          -webkit-animation: spin 2s linear infinite; /* Safari */
          animation: spin 2s linear infinite;
          visibility: hidden;
        }

        /* Animation for the loading icon */
        @-webkit-keyframes spin {
          0% { -webkit-transform: rotate(0deg); }
          100% { -webkit-transform: rotate(360deg); }
        }

        @keyframes spin {
          0% { transform: rotate(0deg); }
          100% { transform: rotate(360deg); }
        }

        /* 1.7 Container for layer order */
        .tree {
            position: absolute;
            color: white;
            top: 13%;
            right: 0;
            margin-right: 420px;
            width: 150px;
            height: 300px;
            background-color: transparent;
            display: flex;
            flex-direction: column;
            transition: margin-right  2s;
            will-change: margin-right;
            z-index: 1;
        }
        
        /* Moves when controls are hidden */
        .tree_move {
            margin-right: 120px;
        }
        
        /* Container for each added layer */
        .tree_element {
            width: 100%;
            background-color: black;
            border-radius: 10px;
            border: solid;
            border-color: white;
            margin: 5px;
            text-align: center;
            height: 30px;
            display: flex;
            flex-direction: row;
            min-height: 30px;
        }
        
        /* Button for removing layers */
        .tree_btn {
           background-color: black;
           border: solid;
           border-color: #555;
           border-width: 2px;
           color: white;
           margin: 5px;
           padding-bottom: 5px;
        }
        
        .tree_btn:hover {
           background-color: #555;
        }
        
        /* Text describing the added layer */
        .tree_text {
           padding-top: 5px;
        }
        
        /* Moves single tree element when dragged */
        #dragg {
            cursor: pointer;
        }
        
    
        /* Resize and hide objects when screen size is reduced below a threshold */
        @media only screen and (max-width:1450px) {
            .inset {
                transition: width 2s,
                            left 2s;
                will-change: width,left;
            }
            
            
            .inset_expand {
                width: 60%;
                left: 15%;
            }
        }
        

        @media only screen and (max-width:1035px) {
            .inset {
                width: 40%;
            }
            
            .inset_expand {
                width: 60%;
            }
        }
        
        @media only screen and (max-width:820px) {
            .inset {
                width: 30%;
            }
            
            .inset_expand {
                width: 60%;
            }
        }
        
        
        @media only screen and (max-width:700px) {
            .inset {
                display: none;
            }
            
            #mobile_inset {
                display: block;
                margin: 20px;
                margin-bottom: 20px;
            }
            
            div.leaflet-control-layers.leaflet-control {
                display: none;
            }
            
            .loader {
                left: 10px;
            }
            
        }
        
        @media only screen and (max-width:600px) {
            #left_header {
                display: none;
            }
            
            #right_header {
                display: none;
            }
            
            #mid_header {
                width: 80%;
            }
            
            #mobile_menu {
                display: block;
                width: 20%;
            }
            
            #mid_header >h1 {
                padding: 0;
                padding-left: 10px;
            }
            
            .tree {
                height: 100px;
            }
            
            .tree_move {
                margin-right: 25px;
            }
            
            .tree_element {
                height: 20px;
            }
            
            .expand_btn {
                position: absolute;
                top: 260px;
                left: -45px;
                width: 35px;
                border-right: none;
                border-bottom-right-radius: 0px;
                border-top-right-radius: 0px;
                opacity: 0.7;
                z-index: 2;
            }
            
            .hide_controls {
                right: -400px;
            }
            
            .hide_expand_btn {
                right: 410px;
            }
            
            #button_container {
                width: 10px;
            }

        }
        
        @media only screen and (max-width:440px) {
            .controls {
                width: 85%;
            }
            
            #input_container {
                width: 85%;
            }
            
            .expand_btn {
                position: absolute;
                top: 260px;
                left: -45px;
                width: 35px;
                border-right: none;
                border-bottom-right-radius: 0px;
                border-top-right-radius: 0px;
                opacity: 0.7;
                z-index: 2;
            }
            
            .hide_controls {
                right: -85%;
            }
            
            .hide_expand_btn {
                right: 85%;
            }
        }
        
    </style>
    <!--js file of the map file-->
    <script>

// Set up custom select boxes
function enableSelectBoxes(){
    // Iterate over all of the custom select boxes
    $('div.selectBox').each(function(){
        // Check whether the selectBox is from the palette input
        if (typeof $(this).children("div.selectOptions").attr("id")!=="undefined"){
            // Set the first select option as default value
            $(this).children('.selectedPalette').html($(this).children('div.selectOptions').children("div.selectOption:first").html());
            // Set the default value
            $(this).attr('value',"viridis");
            // Click event to open/close the select options when arrow or the container showing the selected option is clicked depending on current status
            $(this).children('span.selected,span.selectArrow').click(function(){
                if($(this).parent().children('div.selectOptions').css('display') == 'none'){
                    $(this).parent().children('div.selectOptions').css('display','block');
                } else {
                    $(this).parent().children('div.selectOptions').css('display','none');
                }
            });
            
            // Click event on the option that is clicked
            $(this).find('div.selectOption').click(function(){
                // Close the select options when one option is clicked
                $(this).parent().css('display','none');
                // Assign the value of the selected to the clicked option
                $(this).closest('div.selectBox').attr('value',$(this).attr("class").split(/\s+/)[1]);
                // Assign the clicked option as the selected
                $(this).parent().siblings('.selectedPalette').html($(this).html());
            });
        } else {
            
            // same procedure when the dataset instead of the palette is selected
            //$(this).children('span.selected').html($(this).children('div.selectOptions').children('div.selectGroupOption').children("div.selectOption:first").html());
            //$(this).attr('value',$(this).children('div.selectOptions').children('span.selectOption:first').attr('value'));
            $(this).children('span.selected,span.selectArrow').click(function(){
                if($(this).parent().children('div.selectOptions').css('display') == 'none'){
                    $(this).parent().children('div.selectOptions').css('display','block');
                } else {
                    $(this).parent().children('div.selectOptions').css('display','none');
                }
            });

            $(this).find('div.selectOption').click(function(){
                $(this).parent().parent().css('display','none');
                $(this).closest('div.selectBox').attr('value',$(this).attr('value'));
                $(this).parent().parent().siblings('span.selected').html($(this).html());
            });
            
        }
    });
}
        
const sleep = (ms) => new Promise(r => setTimeout(r, ms));
var killed = false;

async function animation(animation_group,layers,imageBounds,map,added_legend,time){
        window["animation_ls"] = new AsyncList(layers);

        $(".stop_animation").click(function(e){
            e.stopImmediatePropagation();
            if ($(".stop_animation").hasClass("start_animation")){
              window["animation_ls"].resume();
              $(".stop_animation").removeClass("start_animation");
              $(".stop_animation").removeClass("fa-play");
              $(".stop_animation").addClass("fa-pause");
            } else {
              window["animation_ls"].pause();
              window["animation_ls"].justPaused = true;
              $(".stop_animation").addClass("start_animation");
              $(".stop_animation").removeClass("fa-pause");
              $(".stop_animation").addClass("fa-play");   
            }
        });
    
        $(".previous").click(function(e){
            e.stopImmediatePropagation();
           window["animation_ls"].pause();
           $(".stop_animation").addClass("start_animation");
           $(".stop_animation").removeClass("fa fa-pause");
           $(".stop_animation").addClass("fa fa-play");
           if (window["animation_ls"]._index>0){
               if (window["animation_ls"].justPaused){
                   window["animation_ls"]._index -= 3;
                   window["animation_ls"].justPaused = false;
                   window["animation_ls"].animation_index -=2;   
               } else {
                   window["animation_ls"]._index--;
                   window["animation_ls"].animation_index--;
               }
               
               window["animation_ls"].changed = true;
               // Apply pane and location of the boundaries to the image of the raster and create layer
               var raster = L.imageOverlay(window["animation_ls"]._array[window["animation_ls"]._index],imageBounds,{pane: "raster"+added_legend,opacity:0.7});   

               // Remove old layer group
               map.removeLayer(animation_group);
               animation_group.clearLayers();

               // Add the new layer to layer group and bring it back to the map
               animation_group.addLayer(raster);
               animation_group.addTo(map);
            
               
               $("#bar").css("width",String(Math.round((window["animation_ls"].animation_index/(window["animation_ls"]._length-1))*100))+"%");
                if (time!="false"){
                    $("#time").html(time[window["animation_ls"].animation_index])
                }

           }
        });
    
        $(".next").click(function(e){
           e.stopImmediatePropagation();
           window["animation_ls"].pause();
           $(".stop_animation").addClass("start_animation");
           $(".stop_animation").removeClass("fa fa-pause");
           $(".stop_animation").addClass("fa fa-play");
           if (window["animation_ls"]._index<window["animation_ls"]._length){
               if (window["animation_ls"].justPaused){
                   window["animation_ls"]._index--;
                   window["animation_ls"].justPaused = false;
               } else {
                   window["animation_ls"]._index++;
                   window["animation_ls"].animation_index++;
               }
               window["animation_ls"].changed = true;
               // Apply pane and location of the boundaries to the image of the raster and create layer
               var raster = L.imageOverlay(window["animation_ls"]._array[window["animation_ls"]._index],imageBounds,{pane: "raster"+added_legend,opacity:0.7});   

               // Remove old layer group
               map.removeLayer(animation_group);
               animation_group.clearLayers();

               // Add the new layer to layer group and bring it back to the map
               animation_group.addLayer(raster);
               animation_group.addTo(map);
               
               $("#bar").css("width",String(Math.round((window["animation_ls"].animation_index/(window["animation_ls"]._length-1))*100))+"%");
                if (time!="false"){
                        $("#time").html(time[window["animation_ls"].animation_index])
                }

           }
        });

        
         for await (let item of window["animation_ls"]){
             if (!window["animation_ls"].changed){
                 if (!killed){
                     
                    // Apply pane and location of the boundaries to the image of the raster and create layer
                    var raster = L.imageOverlay(item,imageBounds,{pane: "raster"+added_legend,opacity:0.7});   
                    
                     
                    // Remove old layer group
                    map.removeLayer(animation_group);
                    animation_group.clearLayers();

                    // Add the new layer to layer group and bring it back to the map
                    animation_group.addLayer(raster);
                    animation_group.addTo(map);

                     
                    $("#bar").css("width",String(Math.round((window["animation_ls"].animation_index/(window["animation_ls"]._length-1))*100))+"%");
                    if (time!="false"){
                        $("#time").html(time[window["animation_ls"].animation_index])
                    }
                    
                    if (!window["animation_ls"].paused){
                        await sleep(1500);  
                    }
   
                 } else {
                     delete window["animation_ls"];
                     return;
                 }
             }
        }
           
}
        
class AsyncList {
  constructor(array) {
    // shallow copy
    this._array = array.slice();

    this._index = 0;
    this._length = this._array.length;
    this.paused = false;
    this.justPaused = false;
    this.changed = false;
    this._resume = () => {}; // noop, in case `resume` is called before `pause`
    this.animation_index = -1;
  }

  [Symbol.asyncIterator]() {
    return this;
  }

  pause() {
    this.paused = true;
  }

  resume() {
    this.paused = false;
    this._resume();
  }

  next() {

    if (this._index < this._length) {
      if (this.changed){
          this._index++;
          this.changed = false;
      }
      const value = this._array[this._index++];
      this.animation_index++;
      if (this.paused) {
           return new Promise(r => this._resume = r.bind(null,{ value }))     
      } 
      return Promise.resolve({ value })
    } else {
      $(".stop_animation").trigger("click");
      $("#time").html(time[++window["animation_ls"].animation_index])
      return Promise.resolve({ done: true });
    }
  }
    
}
        

$(document).ready(function(){
    
    // 1. Set up default page when page is loaded
    
    // Fit the absolute position of the control menu automatically
    if ($(window).width()<700){
        $(".loader").css("top",$("#map_header").height()+280);
    } else {
        $(".loader").css("top",$("#map_header").height()+330);   
    }
    $(".controls").css("top",$("#map_header").outerHeight(true));
    $(".mobile_menu_bar").css("top",$("#map_header").outerHeight(true))
    $("#form_post_map").css("width",$("#input_container").width()-10);
    $("#form_post_inset").css("width",$("#input_container").width()-10);
    $(".selectOptions").css("width",$(".selectBox").width());
    $(".selectOptions").css("left",($(".selectBox").offset().left-$(".controls").offset().left));
    // Fit the position of the control menu when the window is resized
    $(window).on('resize', function(){
        if ($(window).width()<700){
            $(".loader").css("top",$("#map_header").height()+280);
        } else {
            $(".loader").css("top",$("#map_header").height()+330);   
        }
      $(".controls").css("top",$("#map_header").outerHeight(true));  
      $(".mobile_menu_bar").css("top",$("#map_header").outerHeight(true));
      $(".selectOptions").css("width",$(".selectBox").width());
      $(".selectOptions").css("left",($(".selectBox").offset().left-$(".controls").offset().left));
      $("#form_post_map").css("width",$("#input_container").width()-10);
      $("#form_post_inset").css("width",$("#input_container").width()-10);
      if ($(".fa.fa-angle-double-down").hasClass("hide_i")){
          if ($(window).width()<600){
             $(".leaflet-right .leaflet-control").css("margin-right","25px");   
          } else {
             $(".leaflet-right .leaflet-control").css("margin-right","120px");
          }
      } else {
          $(".leaflet-right .leaflet-control").css("margin-right","420px");
      }
    });
    
    // Fit the position of the control menu when the window is scrolled 
    $("#form_post_map,#form_post_inset").scroll(function(){
        if ($("#form_post_map").css("display")=="flex"){
            $("#form_post_map >> .selectOptions").each(function(){
               $(this).css("top",$(this).closest('div.selectBox').offset().top-$(window).height()*0.08); 
                if ($(this).offset().top<$("#form_post_map").offset().top || ($(this).offset().top+$(this).height())>($("#form_post_map").offset().top)+$("#form_post_map").height()){
                    $(this).css("display","none");
                }  
            });
        } else {
            $("#inset_options").css("top",$("#inset_input_dataset").offset().top+$(window).height()*0.01);
               $("#form_post_inset >> .selectOptions").each(function(){
                $(this).css("top",$(this).closest('div.selectBox').offset().top-$(window).height()*0.08); 
                if ($(this).offset().top<$("#form_post_inset").offset().top || ($(this).offset().top+$(this).height())>($("#form_post_inset").offset().top)+$("#form_post_inset").height()){
                    $(this).css("display","none");
                }  
            });
        }
    });
    

    
    // Set max date of start date when page is loaded
    var today = new Date();
    var dd = today.getDate();
    var mm = today.getMonth()+1;
    var yyyy = today.getFullYear();
     if(dd<10){
            dd='0'+dd
        } 
        if(mm<10){
            mm='0'+mm
        }

    today = yyyy+'-'+mm+'-'+dd;
    $("#start_date").attr("max",today);
    
    
    // Show the selection of possible palettes
    color_select_viridis = d3.scaleSequential().domain([0,100]).interpolator(d3.interpolateViridis);
    color_select_magma = d3.scaleSequential().domain([0,100]).interpolator(d3.interpolateMagma);
    color_select_blues = d3.scaleSequential().domain([0,100]).interpolator(d3.interpolateBlues);
    color_select_reds = d3.scaleSequential().domain([0,100]).interpolator(d3.interpolateReds);
    for (var i=0;i<101;i++){
        $(".viridis").append($(`<i style='background-color:${color_select_viridis(i)};'></i>`));
        $(".magma").append($(`<i style='background-color:${color_select_magma(i)};'></i>`));
        $(".blues").append($(`<i style='background-color:${color_select_blues(i)};'></i>`));
        $(".reds").append($(`<i style='background-color:${color_select_reds(i)};'></i>`));
    }
    
    // Set up the custom select boxes
    enableSelectBoxes();
    
    // Set default plot for the inset
    /*
    var graphs = {{ plt|safe }};
    Plotly.plot('plotly',graphs,{});
    Plotly.plot('mobile_inset',graphs,{});
    
    $(window).resize(function() {
        if($(window).width() < 600){
          var divheight = $("#mobile_inset").height();
          var divwidth = $("#mobile_inset").width();
          var update = {
                  width:divwidth, 
                  height:divheight
                };

          Plotly.relayout('mobile_inset', update);

        } else {
          var divheight = $(".inset").height()-40;
          var divwidth = $(".inset").width()-40;
        }

         var update = {
                  width:divwidth, 
                  height:divheight
                };

        Plotly.relayout('plotly', update);

    }).resize();
    */
    $(".selectBtn").click(function(){
        if ($(this).parent().siblings("div.selectOption").css("display")=="none"){
            $(this).parent().siblings("div.selectOption").css("display","block");
            $(this).html("-");   
        } else {
            $(this).parent().siblings("div.selectOption").css("display","none");
            $(this).html("+");   
        }
    });

    // Create different base layers
    var dark = L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
        subdomains: 'abcd',
        maxZoom: 19
    });
    
    var topo = L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
        maxZoom: 17,
        attribution: 'Map data: &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, <a href="http://viewfinderpanoramas.org">SRTM</a> | Map style: &copy; <a href="https://opentopomap.org">OpenTopoMap</a> (<a href="https://creativecommons.org/licenses/by-sa/3.0/">CC-BY-SA</a>)'
    });
    
    var imagery = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
        attribution: 'Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community'
    });
    
    
    var original = L.tileLayer('http://{s}.tile.osm.org/{z}/{x}/{y}.png', {
        attribution: '&copy; <a href="http://osm.org/copyright">OpenStreetMap</a> contributors'
    });
    
    
    // Initialize the leaflet map and add the tile layers
    var map = L.map('my-map',{layers:[original]}).setView(new L.LatLng(49.451993, 11.073397), 5);
    
    // Define the layer control
    var baseMaps = {"Dark":dark,
                    "Imagery":imagery,
                    "Topo":topo,
                    "Default":original}

    // Set the zindex, so that the drawn features are in front of the loaded layers
    $(".leaflet-marker-pane").css("z-index",650);
    $(".leaflet-overlay-pane").css("z-index",650);
    // initialize the Feature group capturing the drawn features and add it to the map
    var drawnItems = new L.FeatureGroup();
    map.addLayer(drawnItems);
    

    // Control which shapes are allowed to draw
    var drawPluginOptions = {
          position: 'topleft',
          draw: {
            polyline: false,
            polygon: {
              shapeOptions: {
                clickable: false
              }
            },
            circle: false,
            circlemarker: false,
            rectangle: {
              shapeOptions: {
                clickable: false
              }}, 
              marker: {
                  shapeOptions: {
                      clickable: false
                  }
              }},
              edit: {
                featureGroup: drawnItems,
                remove: true
              }
        };

    // Add the control panel for the drawn features to the map
    var drawControl = new L.Control.Draw(drawPluginOptions);
    map.addControl(drawControl);
    
    // Add the base layer control
    L.control.layers(baseMaps,null,{position:"topleft"}).addTo(map);
    
    // 2. Sending data to the flask application and initialize necessary variables for that

    // Handle when data for the inset is sent
    $("#submit_btn_inset").click(function(){
            // Make ajax post to the flask application
            $.ajax({
            url: "/map/plot/data",
            type: "GET",
            contentType: 'application/json;charset=UTF-8',
            data: {
                // Declare the data that is sent 
                "start_date": $("#inset_input_start_date").val(),
                "end_date": $("#inset_input_end_date").val(),
                "inset_dataset": $("#inset_input_dataset .selected").html(),
                "inset_variable": $("#variable_input_inset").val()
            },
            dataType:"json",
            // When the data has been sent successfully handle the response data
            success: function (data) {
                Plotly.newPlot('plotly',data);
                Plotly.newPlot('mobile_inset',data);
                $(".loader").css("visibility","hidden");
            }
            });
         
    });
    
    var time;
    var time_map = "false";
    
    // Update selection of variables for the selected dataset for the map
    $("#form_post_map >> .selectOptions:first >> .selectOption").on("click",function(){
       $(".loader").css("visibility","visible");
       $.ajax({
           url: "map/data/variable",
           type: "GET",
           contentType: 'application/json;charset=UTF-8',
           data: {
               "selected": $("#map_input_dataset .selected").html(),
               "boundaries": boundaries,
           },
           success: function(data) {
               var variables = data.variables;
               var error = data.error;
               var xarr = data.xarr;
               time = data.time;
               var time_length = Object.keys(time).length;
               
               $("#variable_input_map").html("");
               
               if (xarr && time_length>1){
                   $("#time_input_map").css("display","block");
                   $("#time_input_map_label").css("display","block");
                   for (var i=0;i<time_length;i++){
                     $("#time_input_map").append(`<option value='${Object.keys(time)[i]}'>${Object.keys(time)[i]}</option>`);   
                   }
                   $("#animation_play").css("display","block");
                   $("#download").css("display","block");
                   $("#selectOptionsPalette").css("top","468px");
                   time_map = time[$("#time_input_map").val()];
                   
               } else if (xarr && time_length<=1){
                   
                   $("#download").css("display","block");
                   
               }  else {
                   $("#time_input_map").css("display","none");
                   $("#time_input_map_label").css("display","none");
                   $("#animation_play").css("display","none");
                   $("#download").css("display","block");
                   $("#selectOptionsPalette").css("top","428px");
               }
        
               for (var i=0;i<variables.length;i++){
                $("#variable_input_map").append(`<option value='${variables[i]}'>${variables[i]}</option>`);   
               }
               
               
               $(".loader").css("visibility","hidden");
               
                // Check whether an error occured and show a toast message with the error
                if (error!="false"){
                    $("#map_input_dataset > .selected").html("");
                    $(".toast").addClass("toast_show");
                    $("#error_text").html(error);
                    setTimeout(function(){
                        $(".toast").removeClass("toast_show");
                    },5000);
                }
               
           }
       }); 
    });
    
    // Update selection of variables for the selected dataset for the inset
    $("#form_post_inset >> .selectOptions:first >> .selectOption").on("click",function(){
       $(".loader").css("visibility","visible");
       $.ajax({
           url: "map/data/variable",
           type: "GET",
           contentType: 'application/json;charset=UTF-8',
           data: {
               "selected": $("#inset_input_dataset .selected").html()
           },
           success: function(data) {
               var variables = data.variables;
               
               $("#variable_input_inset").html("");
               
                for (var i=0;i<variables.length;i++){
                     $("#variable_input_inset").append(`<option value='${variables[i]}'>${variables[i]}</option>`);   
                }  
               
               $(".loader").css("visibility","hidden");
               
           }
       }); 
    });

    
    // Some Default variables are set 
    var boundaries = "false";
    var marker_loc = "false";
    var inset_dataset = "false";
    
    // Initialize running variables that get updates with different leaflet elements like legends,info,layer etc. objects
    var layer_group = L.layerGroup([]);
    var animation_group = L.layerGroup([]);
    // Initialize dicts for the added legend and info objects
    var info_lst = {};
    var legend_lst = {};
    // Initialize list for id of the added layers
    var id_lst = [];
    // Initialize running variables for how many legend and info objects have been added
    var added_legend = 0;
    var added_info = 0;
    // Initialize a running variable for setting the zindex of newly added layers
    var layer_order = 600;
    // Initialize dict for storing the received data from the flask application
    var data_lst = {};

    
    $("#submit_btn_map").click(function(){
        $.ajax({
        url: "/map/data",
        type: "GET",
        data: {
            // Make ajax post to the flask application
            "dataset": $("#map_input_dataset .selected").html(),
            "filter_operator": $("#map_input_filter_operator").val(),
            "calc_operator": $("#map_input_calc_operator").val(),
            "palette": $("#map_input_palette").attr("value"),
            "value_extraction": $("#map_input_extraction option:selected").val(),
            "boundaries": boundaries,
            "marker_loc": marker_loc,
            "variable": $("#variable_input_map").val(),
            "time": time_map,
            "animation": false,
            "download":false

        },
        // When the data has been sent successfully handle the response data
        success: function (data) {

            
            // Assign the palette to the selected palette
            var palette = $("#map_input_palette").attr("value");
            var variable = $("#variable_input_map").val();
            
            // Reset variables
            boundaries = "false";
            marker_loc = "false";
            
            // Reset output field for value extraction
            $("#value_output").html("");   

            // Read in data from the flask application
            var dat = data;

            var download_data = {
            "dataset": $("#map_input_dataset .selected").html(),
            "filter_operator": $("#map_input_filter_operator").val(),
            "calc_operator": $("#map_input_calc_operator").val(),
            "palette": $("#map_input_palette").attr("value"),
            "value_extraction": $("#map_input_extraction option:selected").val(),
            "boundaries": boundaries,
            "marker_loc": marker_loc,
            "variable": $("#variable_input_map").val(),
            "time": time_map,
            "animation": false,
            "download":true

        };
        
        // Check the data type of the return geospatial information and check whether an error occured
        if (dat.data_type=="shapefile" && dat.error=="false"){
            // Parse the geo file (geojson) as a json file
            var dataset = jQuery.parseJSON(dat.geo_file_shp);
            var geojson
            
            
            // Store the variable of interest of the shapefile in a list
            var data_arr = [];
            for (var i=0;i<dataset.features.length;i++){
                data_arr.push(dataset.features[i].properties[variable]);
            }
            
            if ((Math.max(...data_arr) - Math.min(...data_arr))==0){
                // Create the palette based on the selected palette
                if (palette=="viridis"){
                    var getColor = d3.scaleSequential().domain([0,256]).interpolator(d3.interpolateViridis);
                } else if (palette=="magma") {
                    var getColor = d3.scaleSequential().domain([0,256]).interpolator(d3.interpolateMagma);
                } else if (palette=="reds"){
                    var getColor = d3.scaleSequential().domain([0,256]).interpolator(d3.interpolateReds);
                } else {
                    var getColor = d3.scaleSequential().domain([0,256]).interpolator(d3.interpolateBlues);
                }    
            } else {
                // Create the palette based on the selected palette
                if (palette=="viridis"){
                    var getColor = d3.scaleSequential().domain([Math.min(...data_arr),Math.max(...data_arr)]).interpolator(d3.interpolateViridis);
                } else if (palette=="magma") {
                    var getColor = d3.scaleSequential().domain([Math.min(...data_arr),Math.max(...data_arr)]).interpolator(d3.interpolateMagma);
                } else if (palette=="reds"){
                    var getColor = d3.scaleSequential().domain([Math.min(...data_arr),Math.max(...data_arr)]).interpolator(d3.interpolateReds);
                } else {
                    var getColor = d3.scaleSequential().domain([Math.min(...data_arr),Math.max(...data_arr)]).interpolator(d3.interpolateBlues);
                }    
            }
            
            
            var partition;
            // Calculate the size of the steps for the legend
            // The legend always consists of 10 groups
            if ((Math.max(...data_arr) - Math.min(...data_arr))/10>=1){
                partition = Math.round((Math.max(...data_arr) - Math.min(...data_arr))/10);
            } else {
                partition = (Math.max(...data_arr) - Math.min(...data_arr))/10;
            }
            // Calculate to which decimal the steps should be rounded
            var size = Math.pow(10, Math.ceil(Math.log10(1/partition)));

            // Style the geojson dataset for the leaflet map
            function dataset_style(feature) {
                return {
                    fillColor: getColor(feature.properties[variable]),
                    weight: 2,
                    opacity: 1,
                    color: 'white',
                    dashArray: '3',
                    fillOpacity: 0.7
                    };
            }


            // Define listeners for mouse events on the shapefile

            // Mouse over shapefile
            function highlightFeature(e) {
                var layer = e.target;

                layer.setStyle({
                    weight: 5,
                    color: '#666',
                    dashArray: '',
                    fillOpacity: 0.7
                });

                if (!L.Browser.ie && !L.Browser.opera && !L.Browser.edge) {
                    layer.bringToFront();
                }
                info.update(layer.feature.properties);
            }

            // Mouse off shapefile
            function resetHighlight(e) {
                geojson.resetStyle(e.target);
                info.update();
            }

            // On click shapefile
            function zoomToFeature(e) {
                map.fitBounds(e.target.getBounds());
            }

            // Assign listeners in a function
            function onEachFeature(feature, layer) {
                layer.on({
                    mouseover: highlightFeature,
                    mouseout: resetHighlight,
                    click: zoomToFeature
                });
            }
            
            // Add pane with increased zindex, so the newly added layer is on top of the others
            map.createPane("shapefile"+added_legend);
            map.getPane("shapefile"+added_legend).style.zIndex = layer_order;
            // Increment zindex for the next layer that will be added
            layer_order += 50;
            
            
            // Apply style, listeners and the pane to the shapefile and create layer
            geojson = L.geoJSON(dataset,{style: dataset_style,
                                        onEachFeature: onEachFeature,
                                        pane: "shapefile"+added_legend});

            
            // Remove old layer group
            map.removeLayer(layer_group);
            // Add the new layer to layer group and bring it back to the map
            layer_group.addLayer(geojson);
            layer_group.addTo(map);
            
            
            // prepend a new tree element based on the added layer
            $(".tree").prepend($(`<div class='tree_element'><button class='tree_btn' id=${geojson._leaflet_id}>x</button><p class='tree_text'>${$("#map_input_dataset .selected").html()+'_'+String(added_legend+1)}</p></div>`));
            // Add the id of added layer to the list of ids
            id_lst.push(geojson._leaflet_id);

            // Create custom info box    
            var info = L.control({position: "bottomright"});

            // Method that will be used when the info object is added to the map
            info.onAdd = function (map) {
                this._div = L.DomUtil.create('div', 'info');
                this.update();
                return this._div;
            };


            // Method that we will use to update the control based on feature properties that get hoverd on
            info.update = function (props) {
                this._div.innerHTML = '<h4>Mean areal precipitation</h4>' +  (props ?
                    '<b>' + props[variable] + ' [mm/y]'
                    : 'Hover over a state');
            };
            
            // Based on the fact whether there is already a info object added to the map, add the info object (and remove the old one) to the map
            if (added_info==0){
                info.addTo(map);
                added_info++;
            } else {
                info_lst[id_lst[added_info-1]].remove();
                info.addTo(map);
                added_info++;
            }
            
            // Add the info object to the dict
            info_lst[geojson._leaflet_id] = info;

            // Create custom legend
            var legend = L.control({position: 'bottomleft'});

            // Method that will be used when the legend object is added to the map
            legend.onAdd = function (map) {         
                var div = L.DomUtil.create('div', 'legend'); 
                
                if ((Math.max(...data_arr) - Math.min(...data_arr))==0){
                    div.innerHTML +=
                        '<div style="display: flex; flex-direction: row;"><i style="height: auto;background:' + getColor(Math.round((i + partition + Number.EPSILON)*size)/size) + '"></i>' +
                        '<p class="legend_element">' +Math.round((i+Number.EPSILON)*size)/size + /*(i<Math.round((Math.max(...data_arr)-partition+Number.EPSILON)*100)/100 ?*/ '&ndash;' + Math.round((i+partition+Number.EPSILON)*size)/size + /*: '+') +*/ '</p>' + '</div>';
                } else {
                 
                    // Loop through our density intervals and generate a label with a colored square for each interval
                    for (var i = Math.round((Math.min(...data_arr)+Number.EPSILON)*size)/size; Math.round((i+Number.EPSILON)*size)/size < Math.round((Math.max(...data_arr)+Number.EPSILON)*size)/size; i += partition) {
                        div.innerHTML +=
                            '<div style="display: flex; flex-direction: row;"><i style="height: auto;background:' + getColor(Math.round((i + partition + Number.EPSILON)*size)/size) + '"></i>' +
                            '<p class="legend_element">' +Math.round((i+Number.EPSILON)*size)/size + /*(i<Math.round((Math.max(...data_arr)-partition+Number.EPSILON)*100)/100 ?*/ '&ndash;' + Math.round((i+partition+Number.EPSILON)*size)/size + /*: '+') +*/ '</p>' + '</div>';
                    }
                    
                }
                

                return div;
            };
            
            // Based on the fact whether there is already a legend object added to the map, add the legend object (and remove the old one) to the map
            if (added_legend==0){
                legend.addTo(map);
                added_legend++;
            } else {
                legend_lst[id_lst[added_legend-1]].remove();
                legend.addTo(map);
                added_legend++;
                }
            
            // Add the legend object to the dict
            legend_lst[geojson._leaflet_id] = legend;
            
            // add all of the received data to the list
            if (dat.xarr==true){
               download_data.name = $("#map_input_dataset .selected").html()+'_'+String(added_legend);
               data_lst[geojson._leaflet_id] = download_data;   
            }
            
            

        } else if (dat.data_type=="raster" && dat.error=="false"){
            

            // Read the coord of the boundaries of the raster image
            var bounds = dat.raster_bounds; 
            var imageBounds = [[bounds[1],bounds[0]], [bounds[3], bounds[2]]];
            // Read the raster image as a binary string
            var imgageUrl = dat.geo_file_rast;
            // Read the range of values of the raster
            var raster_range = dat.raster_range;
            // Read summary statistics of the raster
            var raster_stats = dat.raster_stats;

            
            if ((raster_range[1]-raster_range[0])==0){
                // Create the palette based on the selected palette
                if (palette=="viridis"){
                    var getColor = d3.scaleSequential().domain([0,256]).interpolator(d3.interpolateViridis);
                } else if (palette=="magma") {
                    var getColor = d3.scaleSequential().domain([0,256]).interpolator(d3.interpolateMagma);
                } else if (palette=="reds"){
                    var getColor = d3.scaleSequential().domain([0,256]).interpolator(d3.interpolateReds);
                } else {
                    var getColor = d3.scaleSequential().domain([0,256]).interpolator(d3.interpolateBlues);
                } 
            } else  {
                // Create the palette based on the selected palette
                if (palette=="viridis"){
                    var getColor = d3.scaleSequential().domain(raster_range).interpolator(d3.interpolateViridis);
                } else if (palette=="magma") {
                    var getColor = d3.scaleSequential().domain(raster_range).interpolator(d3.interpolateMagma);
                } else if (palette=="reds"){
                    var getColor = d3.scaleSequential().domain(raster_range).interpolator(d3.interpolateReds);
                } else {
                    var getColor = d3.scaleSequential().domain(raster_range).interpolator(d3.interpolateBlues);
                }   
            }
            var partition;
            // Calculate the size of the steps for the legend
            // The legend always consists of 10 groups
            /*if ((raster_range[1] - raster_range[0])/256>=1){
                partition = Math.round((raster_range[1]-raster_range[0])/256);
            } else {
                partition = (raster_range[1] - raster_range[0])/256;
            }*/
            // Calculate to which decimal the steps should be rounded
            var partition = (raster_range[1] - raster_range[0])/256;
            var size = Math.pow(10, Math.ceil(Math.log10(1/partition)));
            
            
            // Add pane with increased zindex, so the newly added layer is on top of the others
            map.createPane("raster"+added_legend);
            map.getPane("raster"+added_legend).style.zIndex = layer_order;
            // Increment zindex for the next layer that will be added
            layer_order += 50;
            
            // Apply pane and location of the boundaries to the image of the raster and create layer
            var raster = L.imageOverlay(imgageUrl,imageBounds,{pane: "raster"+added_legend,opacity:0.7});

            // Remove old layer group
            map.removeLayer(layer_group);
            // Add the new layer to layer group and bring it back to the map
            layer_group.addLayer(raster);
            layer_group.addTo(map);


            // prepend a new tree element based on the added layer
            $(".tree").prepend($(`<div class='tree_element'><button class='tree_btn' id=${raster._leaflet_id}>x</button><p class='tree_text'>${$("#map_input_dataset .selected").html()+'_'+String(added_legend+1)}</p></div>`));
            // Add the id of added layer to the list of ids
            id_lst.push(raster._leaflet_id);
            
            // Create custom info box
            var info = L.control({position: "bottomright"});

            // Method that will be used when the info object is added to the map
            info.onAdd = function (map) {
                this._div = L.DomUtil.create('div', 'info'); // create a div with a class "info"
                this._div.innerHTML = `<h4>Mean Areal Precipitation</h4><p style='color:black;'>Overall sum:${raster_stats.sum}</p>
                <p style='color:black;'>Overall mean:${raster_stats.mean}</p>`;
                return this._div;
            };
            
            // Based on the fact whether there is already a info object added to the map, add the info object (and remove the old one) to the map
            if (added_info==0){
                info.addTo(map);
                added_info++;
            } else {
                info_lst[id_lst[added_info-1]].remove();
                info.addTo(map);
                added_info++;
            }

            // Add the info object to the dict
            info_lst[raster._leaflet_id] = info;
            
            // Create custome legend
            var legend = L.control({position: 'bottomleft'});

            // Method that will be used when the legend object is added to the map
            legend.onAdd = function (map) {

                    var div = L.DomUtil.create('div', 'legend');
                
                    if ((raster_range[1]-raster_range[0])==0){
                        div.innerHTML +=
                            '<div style="display: flex; flex-direction: row;"><i style="height: auto;background:' + getColor(0) + '"></i>' +
                            '<p class="legend_element">'+ raster_range[0] +'</p></div>';   
                    } else {
                     
                        div.innerHTML +=
                        '<div style="display: flex; flex-direction: row;">' +
                        '<p class="legend_element">' + Math.round((raster_range[0]+Number.EPSILON)*size)/size + '</p>' + '</div>';

                        // Loop through our density intervals and generate a label with a colored square for each interval
                        for (var i = raster_range[0]-partition; i <= raster_range[1]+partition; i += partition) {
                                div.innerHTML +=
                                '<div style="display: flex; flex-direction: row;"><i style="background:' + getColor(i) + '"></i>' +
                                '<p class="legend_element"></p></div>';   
                        }

                        div.innerHTML +=
                                '<div style="display: flex; flex-direction: row;">' +
                                '<p class="legend_element">' + Math.round((raster_range[1]+Number.EPSILON)*size)/size + '</p>' + '</div>';
                        
                    }

                    return div;
                };

            // Based on the fact whether there is already a legend object added to the map, add the legend object (and remove the old one) to the map
            if (added_legend==0){
                legend.addTo(map);
                added_legend++;
            } else {
                legend_lst[id_lst[added_legend-1]].remove();
                legend.addTo(map);
                added_legend++;
            }
            
            // Add the legend object to the dict
            legend_lst[raster._leaflet_id] = legend;
            // add all of the received data to the list
            if (dat.xarr==true){
                download_data.name = $("#map_input_dataset .selected").html()+'_'+String(added_legend);
                data_lst[raster._leaflet_id] = download_data;
            }
            

        }
            // Check whether an error occured and show a toast message with the error
            if (dat.error!="false"){
                $(".toast").addClass("toast_show");
                $("#error_text").html(dat.error);
                setTimeout(function(){
                    $(".toast").removeClass("toast_show");
                },5000);
            }
            
            // Show the extracted value if any of the value extraction options was selected
            if (dat.value!="false"){
              $("#value_output").html(dat.value);   
            }
            // Hide the loader
            $(".loader").css("visibility","hidden");
            // Clear drawn layers
            drawnItems.clearLayers();
        }
        });
     });
    
    $("#test").click(function(){
        var test_data = JSON.stringify({"test":{"as":"sd"}});
        $.ajax({
        url: "/map/download_prep",
        type: "GET",
        data: {"data":test_data}
        });
    });
    
    $("#download").click(function(){
        $(".download_control").addClass("download_show");
        $(".exit_bar").css("display","flex");
        
        for (var i in data_lst){
            if ($(".download_control").children(`#${i}`).length==0){
                
                $(".download_control").prepend($(`<div class='download_dataset' id=${i}>
                <input type='checkbox' class='download_checkbox'>
                <p style='padding-left: 25px;'>${data_lst[i].name}</p>
                </div>`))  
                    
            }
        }
        
        $("#main_container").children().not(".download_control, .toast, .exit_bar").css("filter","blur(5px)");
    });
    
    $(".submit_download").click(function(){
        var downloaded_sets = {};
        var name_arr = $(".download_control").children(".download_dataset");
        $(".download_control").children(".download_dataset").each(function(){
                if ($(this).children("input[type=checkbox]")[0].checked) {
                    downloaded_sets[$(this).attr("id")] = data_lst[$(this).attr("id")];
                }
        });

        downloaded_sets = JSON.stringify(downloaded_sets);
        
        $.ajax({
        url: "/map/download_prep",
        type: "GET",
        contentType: "application/json",
        data: {
            /*
            // Make ajax post to the flask application
            "dataset": $("#map_input_dataset .selected").html(),
            "filter_operator": $("#map_input_filter_operator").val(),
            "calc_operator": $("#map_input_calc_operator").val(),
            "palette": $("#map_input_palette").attr("value"),
            "value_extraction": $("#map_input_extraction option:selected").val(),
            "boundaries": boundaries,
            "marker_loc": marker_loc,
            "variable": $("#variable_input_map").val(),
            "time": time_map,
            "animation": false,
            "download": true
            */
            
            "data":downloaded_sets

        }, success:function(data){
            window.location.href = "map/download";
        },
            dataType: "json"
        });
    });

    
    $(".exit_bar > i").click(function(e){
        e.stopImmediatePropagation();
       $(".download_control").removeClass("download_show");
       $("#main_container").children().not(".download_control, .toast").css("filter","none");
       $(".exit_bar").css("display","none"); 
    });
    
    var animation_data;
    
    $("#animation_play").click(function(){
        $(".loader").css("visibility","visible");
        $(".animation_control").css("display","grid");
        $("#bar").css("width","0%");
        killed = false;
        $.ajax({
        url: "/map/data",
        type: "GET",
        data: {
            // Make ajax post to the flask application
            "dataset": $("#map_input_dataset .selected").html(),
            "filter_operator": $("#map_input_filter_operator").val(),
            "calc_operator": $("#map_input_calc_operator").val(),
            "palette": $("#map_input_palette").attr("value"),
            "value_extraction": $("#map_input_extraction option:selected").val(),
            "boundaries": boundaries,
            "marker_loc": marker_loc,
            "variable": $("#variable_input_map").val(),
            "animation": true,
            "time":"",
            "download":false

        }, success:function(data){
            animation_data = data;
            
            // Assign the palette to the selected palette
            var palette = $("#map_input_palette").attr("value");
            var variable = $("#variable_input_map").val();
            
            // Reset variables
            boundaries = "false";
            marker_loc = "false";
            
            // Reset output field for value extraction
            $("#value_output").html("");   

            // Read in data from the flask application
            var dat = data;
            
            // Set error when there is already a animation running
            if (typeof id_lst["0"] !== 'undefined'){
                dat.error = "Animation is already running. There is only one animation possible at once"
            }

            
            if (dat.error=="false"){

                // Read the coord of the boundaries of the raster image
                var bounds = dat.raster_bounds; 
                var imageBounds = [[bounds[1],bounds[0]], [bounds[3], bounds[2]]];
                // Read the raster image as a binary string
                var imgageUrl = dat.geo_file_rast;
                // Read the range of values of the raster
                var raster_range = dat.raster_range;
                // Read summary statistics of the raster
                var raster_stats = dat.raster_stats;
                var animation_id = "0";
                var time = dat.time;

                // Create the palette based on the selected palette
                if (palette=="viridis"){
                    var getColor = d3.scaleSequential().domain(raster_range).interpolator(d3.interpolateViridis);
                } else if (palette=="magma") {
                    var getColor = d3.scaleSequential().domain(raster_range).interpolator(d3.interpolateMagma);
                } else if (palette=="reds"){
                    var getColor = d3.scaleSequential().domain(raster_range).interpolator(d3.interpolateReds);
                } else {
                    var getColor = d3.scaleSequential().domain(raster_range).interpolator(d3.interpolateBlues);
                }


                var partition;
                // Calculate the size of the steps for the legend
                // The legend always consists of 10 groups
                /*if ((raster_range[1] - raster_range[0])/256>=1){
                    partition = Math.round((raster_range[1]-raster_range[0])/256);
                } else {
                    partition = (raster_range[1] - raster_range[0])/256;
                }*/
                // Calculate to which decimal the steps should be rounded
                var partition = (raster_range[1] - raster_range[0])/256;
                var size = Math.pow(10, Math.ceil(Math.log10(1/partition)));


                // Add pane with increased zindex, so the newly added layer is on top of the others
                map.createPane("raster"+added_legend);
                map.getPane("raster"+added_legend).style.zIndex = layer_order;
                // Increment zindex for the next layer that will be added
                layer_order += 50;

                animation(animation_group,imgageUrl,imageBounds,map,added_legend,time);

                // prepend a new tree element based on the added layer
                $(".tree").prepend($(`<div class='tree_element'><button class='tree_btn' id=${animation_id}>x</button><p class='tree_text'>${$("#map_input_dataset .selected").html()+'_'+String(added_legend+1)}</p></div>`));
                // Add the id of added layer to the list of ids
                id_lst.push(animation_id);

                // Create custom info box
                var info = L.control({position: "bottomright"});

                // Method that will be used when the info object is added to the map
                info.onAdd = function (map) {
                    this._div = L.DomUtil.create('div', 'info'); // create a div with a class "info"
                    this._div.innerHTML = `<h4>Mean Areal Precipitation</h4><p style='color:black;'>Timesteps:${raster_stats.length}</p>;`
                    return this._div;
                };

                // Based on the fact whether there is already a info object added to the map, add the info object (and remove the old one) to the map
                if (added_info==0){
                    info.addTo(map);
                    added_info++;
                } else {
                    info_lst[id_lst[added_info-1]].remove();
                    info.addTo(map);
                    added_info++;
                }

                // Add the info object to the dict
                info_lst[animation_id] = info;

                // Create custome legend
                var legend = L.control({position: 'bottomleft'});

                // Method that will be used when the legend object is added to the map
                legend.onAdd = function (map) {

                    var div = L.DomUtil.create('div', 'legend');
                
                    div.innerHTML +=
                            '<div style="display: flex; flex-direction: row;">' +
                            '<p class="legend_element">' + Math.round((raster_range[0]+Number.EPSILON)*size)/size + '</p>' + '</div>';

                    // Loop through our density intervals and generate a label with a colored square for each interval
                    for (var i = raster_range[0]-partition; i <= raster_range[1]+partition; i += partition) {
                            div.innerHTML +=
                            '<div style="display: flex; flex-direction: row;"><i style="background:' + getColor(i) + '"></i>' +
                            '<p class="legend_element"></p></div>';   
                    }
                
                    div.innerHTML +=
                            '<div style="display: flex; flex-direction: row;">' +
                            '<p class="legend_element">' + Math.round((raster_range[1]+Number.EPSILON)*size)/size + '</p>' + '</div>';

                    return div;
                };

                // Based on the fact whether there is already a legend object added to the map, add the legend object (and remove the old one) to the map
                if (added_legend==0){
                    legend.addTo(map);
                    added_legend++;
                } else {
                    legend_lst[id_lst[added_legend-1]].remove();
                    legend.addTo(map);
                    added_legend++;
                }

                // Add the legend object to the dict
                legend_lst[animation_id] = legend;
                // add all of the received data to the list
                //data_lst[animation_id] = dat;     
            }
            
            // Check whether an error occured and show a toast message with the error
            if (dat.error!="false"){
                $(".toast").addClass("toast_show");
                $("#error_text").html(dat.error);
                setTimeout(function(){
                    $(".toast").removeClass("toast_show");
                },5000);
            }

            // Hide the loader
            $(".loader").css("visibility","hidden");
            // Clear drawn layers
            drawnItems.clearLayers();
        }
    });
    });
    
    
    // 3. Set up listeners
    
    // Handle the drawing of features
    map.on('draw:created', function(e) {
      // Previous drawn features are deleted
      drawnItems.clearLayers();
      var layer = e.layer;
      // Check whether the drawn feature is a marker or not
      if (layer instanceof L.Marker){
          // Put marker on pane which is added in front of added layers
          $(".leaflet-marker-pane").css("z-index",layer_order+50);
          // get coordinates of drawn marker and override variable 'marker_loc' and set back 'boundaries' variable
          var coord = layer.getLatLng();
          var lat = coord.lat;
          var lng = coord.lng;
          marker_loc = JSON.stringify({"lat":lat,"lng":lng});
          boundaries = "false";
      } else {
          // Put polygon/rectangle on pane which is added in front of added layers
          $(".leaflet-overlay-pane").css("z-index",layer_order+50);
          // get coordinates of drawn polygon/rectangle and override variable 'boundaries' and set back 'marker_loc' variable
          boundaries = JSON.stringify(layer.toGeoJSON());
          marker_loc = "false";

      }
        
      // Add drawn layer to the feature group which is already added to the map
      drawnItems.addLayer(layer);  
    });

    // Handle the expanding of the control menu with adding/removing classes which change the position of elements or change
    // the position directly
    $(".expand_btn").click(function(event){
        if (!$(".fa.fa-angle-double-down").hasClass("hide_i")){
            event.stopPropagation();
            $(".fa.fa-angle-double-down").addClass("hide_i");
            $(".controls").addClass("hide_controls");
            $(".expand_btn").addClass("hide_expand_btn");
            $(".inset").addClass("inset_expand");
            if($(window).width() < 600){
                $(".leaflet-right .leaflet-control").css("margin-right","25px");
            } else {
                $(".leaflet-right .leaflet-control").css("margin-right","120px");   
            }
            $(".tree").addClass("tree_move");
            $(".animation_control").addClass("animation_expand");
        } else {
            event.stopPropagation();
            $(".fa.fa-angle-double-down").removeClass("hide_i");
            $(".controls").removeClass("hide_controls");
            $(".expand_btn").removeClass("hide_expand_btn");
            $(".inset").removeClass("inset_expand");
            $(".leaflet-right .leaflet-control").css("margin-right","420px");
            $(".tree").removeClass("tree_move");
            $(".animation_control").removeClass("animation_expand");
        }
    });

    // Handle when inset button is clicked with showing the inset
    $("#inset_btn").on({
       click: function(){
           $("#inset_btn").css("opacity","1");
           $("#map_btn").css("opacity","0.5");
           $(".inset").addClass("inset_show");
           $("#form_post_map").hide();
           $("#form_post_inset").css("display","flex");
       }
    });

    // Handle when map button is clicked with showing the map
    $("#map_btn").on({
       click: function(){
           $("#map_btn").css("opacity","1");
           $("#inset_btn").css("opacity","0.5");
           $(".inset").removeClass("inset_show");
           $("#form_post_map").show();
           $("#form_post_inset").hide();
       }
    });
    
    $(".replay").click(function(){
        var bounds = animation_data.raster_bounds; 
        var imageBounds = [[bounds[1],bounds[0]], [bounds[3], bounds[2]]];
        $("#bar").css("width","0%");
        $(".stop_animation").removeClass("start_animation");
        $(".stop_animation").removeClass("fa-play");
        $(".stop_animation").addClass("fa-pause");
        animation(animation_group,animation_data.geo_file_rast,imageBounds,map,added_legend,animation_data.time);
    });

    // Handle the loader when submit buttons are clicked with making it visible
    $("#submit_btn_map").click(function(){
       $(".loader").css("visibility","visible");
    });
    
    $("#submit_btn_inset").click(function(){
       $(".loader").css("visibility","visible");
    });
    
    // Handle the mobile menu when icon is clicked
    $(".mobile_menu_icon").click(function(){
       if (!$(this).hasClass("mobile_menu_show")){
           $(this).addClass("mobile_menu_show");
           $(".mobile_menu_bar").css("display","flex");
       } else {
           $(this).removeClass("mobile_menu_show");
           $(".mobile_menu_bar").css("display","none");
       }
    });
    
    // Handle when the button to remove a tree element is clicked
    $(".tree").on("click",".tree_btn",function(){
        // Get id of the clicked button
        id = parseInt(this.id);
        
        if (id=="0"){
            map.removeLayer(animation_group);
            $(".animation_control").css("display","none");
            killed = true;
            $(".stop_animation").removeClass("start_animation");
            $(".stop_animation").removeClass("fa fa-play");
            $(".stop_animation").addClass("fa fa-pause");
        }
        
        map.removeLayer(layer_group);
        // Remove the id from the layer group and add it back to the map
        layer_group.removeLayer(id);
        layer_group.addTo(map);
        // Remove the tree element with the id
        $(`#${id}`).parent().remove();
        // remove the legend and info of the layer with the id
        legend_lst[id].remove();
        info_lst[id].remove();
        // Remove the entries in the dict of legend and info object and in the list of ids with the id
        delete info_lst[id];
        delete legend_lst[id];
        delete data_lst[id];
        $(".download_control").children(`#${id}`).remove();
        id_lst.splice(id_lst.indexOf(id),1);
        // Check whether the removed layer was on top
        // If so bring next legend and info object to the top 
        if (id>Math.max(...id_lst)){
            if (Object.keys(legend_lst).length>0){
                legend_lst[id_lst[id_lst.length-1]].addTo(map);
                info_lst[id_lst[id_lst.length-1]].addTo(map);   
            }   
        } 
        // Decrement running variables
        added_legend--;
        added_info--;
        layer_order -= 50;

    });

    // Handle when the tree elements are dragged
    $( function() {
        $( "#dragg" ).sortable({
            stop:  function(event,ui){
                /*
                pos_ls = {};
                $("div","#dragg").each(function(){
                    id = $(this).children(".tree_btn").attr("id");
                    pos_ls[id] = $(this).position().top;
                });
                
                // Create items array
                var items = Object.keys(pos_ls).map(function(key) {
                  return [key, pos_ls[key]];
                });

                // Sort the array based on the second element
                items.sort(function(first, second) {
                  return second[1] - first[1];
                });

                var temp_sorted = items;
                var sorted_lst = [];
                for (var i=0;i<temp_sorted.length;i++){
                  sorted_lst.push(parseInt(temp_sorted[i][0]));
                }
                
                

                map.removeLayer(layer_group);
                info_lst[id_lst[id_lst.length-1]].remove();
                legend_lst[id_lst[id_lst.length-1]].remove();
                for (var i=0;i<id_lst.length;i++){
                    $(`#${id_lst[i]}`).parent().remove();
                }
            
                var temp_layer = L.layerGroup([]);
                layer_group = temp_layer;
                
        
                info_lst = {};
                legend_lst = {};
                id_lst = [];
                added_legend = 0;
                added_info = 0;
                layer_order = 600;
                pane_lst = {};
                order_lst = {};
            
                for (var j=0;j<sorted_lst.length;j++){
                    var dat = data_lst[sorted_lst[j]];
                    console.log(dat);
                    if (dat.data_type=="shapefile" && dat.error=="false"){
                        var dataset = jQuery.parseJSON(dat.geo_file_shp);
                        var geojson

                        var data_arr = [];
                        for (var i=0;i<dataset.features.length;i++){
                            data_arr.push(dataset.features[i].properties.prec);
                        }
                        

                        if (dat.palette=="viridis"){
                            var getColor = d3.scaleSequential().domain([Math.min(...data_arr),Math.max(...data_arr)]).interpolator(d3.interpolateViridis);
                        } else if (dat.palette=="magma") {
                            var getColor = d3.scaleSequential().domain([Math.min(...data_arr),Math.max(...data_arr)]).interpolator(d3.interpolateMagma);
                        }
                        var partition = Math.round((Math.max(...data_arr) - Math.min(...data_arr))/10);

                        // style the geojson dataset for the leaflet map


                        function dataset_style(feature) {
                            return {
                                fillColor: getColor(feature.properties.prec),
                                weight: 2,
                                opacity: 1,
                                color: 'white',
                                dashArray: '3',
                                fillOpacity: 0.7
                                };
                        }


                        // define functions for mouse events
                        /*
                        // mouse over event
                        function highlightFeature(e) {
                            var layer = e.target;

                            layer.setStyle({
                                weight: 5,
                                color: '#666',
                                dashArray: '',
                                fillOpacity: 0.7
                            });

                            if (!L.Browser.ie && !L.Browser.opera && !L.Browser.edge) {
                                layer.bringToFront();
                            }
                            info.update(layer.feature.properties);
                        }

                        // mous off event
                        function resetHighlight(e) {
                            geojson.resetStyle(e.target);
                            info.update();
                        }

                        // on click event
                        function zoomToFeature(e) {
                            map.fitBounds(e.target.getBounds());
                        }

                        // set listeners
                        function onEachFeature(feature, layer) {
                            layer.on({
                                mouseover: highlightFeature,
                                mouseout: resetHighlight,
                                click: zoomToFeature
                            });
                        }
                    

                        // add pane with z-index
                        map.createPane("shapefile"+added_legend);
                        map.getPane("shapefile"+added_legend).style.zIndex = layer_order;
                        layer_order += 50;

                        // add popup to dataset layer
                        geojson = L.geoJSON(dataset,{style: dataset_style,
                                                    //onEachFeature: onEachFeature,
                                                    pane: "shapefile"+added_legend});
                        pane_lst[geojson._leaflet_id] = map.getPane("shapefile"+added_legend);
                        order_lst[geojson._leaflet_id] = layer_order-50;
                        
                        //geojson = L.geoJSON(dataset);
                        map.removeLayer(layer_group);
                        layer_group.addLayer(geojson);
                        layer_group.addTo(map);


                        var layer_lst = [];
                        layer_group.eachLayer(function(layer){
                            layer_lst.push(layer);
                        });

                        $(".tree").prepend($(`<div class='tree_element'><button class='tree_btn' id=${geojson._leaflet_id}>x</button><p class='tree_text'>${$("#map_input_dataset option:selected").val()+'_'+String(layer_lst.length)}</p></div>`));

                        id_lst.push(geojson._leaflet_id);

                        // custom info box

                        var info = L.control({position: "bottomright"});

                        info.onAdd = function (map) {
                            this._div = L.DomUtil.create('div', 'info'); // create a div with a class "info"
                            this.update();
                            return this._div;
                        };


                        // method that we will use to update the control based on feature properties passed
                        info.update = function (props) {
                            this._div.innerHTML = '<h4>Mean areal precipitation</h4>' +  (props ?
                                '<b>' + props.prec + ' [mm/y]'
                                : 'Hover over a state');
                        };

                        if (added_info==0){
                            info.addTo(map);
                            added_info++;
                        } else {
                            info_lst[id_lst[added_info-1]].remove();
                            info.addTo(map);
                            added_info++;
                        }
                        

                        info_lst[geojson._leaflet_id] = info;

                        // set up legend
                        console.log(legend);
                        var legend = L.control({position: 'bottomleft'});


                        legend.onAdd = function (map) {         
                            var div = L.DomUtil.create('div', 'legend');
                            console.log(data_arr);
                            // loop through our density intervals and generate a label with a colored square for each interval
                            for (var i = Math.min(...data_arr); i < (Math.max(...data_arr)); i += partition) {
                                div.innerHTML +=
                                    '<div style="display: flex; flex-direction: row;"><i style="background:' + getColor((i + partition)) + '"></i>' +
                                    '<p class="legend_element">' +i + (i<(Math.max(...data_arr)-partition) ? '&ndash;' + (i+partition) : '+') + '</p>' + '</div>';
                            }
                            return div;
                        };
                        

                        if (added_legend==0){
                            console.log(legend);
                            legend.addTo(map);
                            added_legend++;
                        } else {
                            console.log(legend);
                            legend_lst[id_lst[added_legend-1]].remove();
                            legend.addTo(map);
                            added_legend++;
                        }
                        
                        legend_lst[geojson._leaflet_id] = legend; 


                    } else if (dat.data_type=="raster" && dat.error=="false"){

                        var bounds = dat.raster_bounds; 
                        var imageBounds = [[bounds[1],bounds[0]], [bounds[3], bounds[2]]];
                        var imgageUrl = dat.geo_file_rast;
                        var raster_range = dat.raster_range;
                        var palette = $("#map_input_palette option:selected").val();
                        var raster_stats = dat.raster_stats;

                        if (dat.palette=="viridis"){
                            var getColor = d3.scaleSequential().domain(raster_range).interpolator(d3.interpolateViridis);
                        } else if (dat.palette=="magma") {
                            var getColor = d3.scaleSequential().domain(raster_range).interpolator(d3.interpolateMagma);
                        }

                        var partition = Math.round((raster_range[1] - raster_range[0])/10);


                        // add pane with z-index
                        map.createPane("raster"+added_legend);
                        map.getPane("raster"+added_legend).style.zIndex = layer_order;
                        layer_order += 50;

                        var raster = L.imageOverlay(imgageUrl,imageBounds,{pane: "raster"+added_legend});
                        pane_lst[raster._leaflet_id] = map.getPane("raster"+added_legend);
                        order_lst[raster._leaflet_id] = layer_order-50;

                        map.removeLayer(layer_group);
                        layer_group.addLayer(raster);
                        layer_group.addTo(map);

                        var layer_lst = [];
                        layer_group.eachLayer(function(layer){
                            layer_lst.push(layer);
                        });

                        $(".tree").prepend($(`<div class='tree_element'><button class='tree_btn' id=${raster._leaflet_id}>x</button><p class='tree_text'>${$("#map_input_dataset option:selected").val()+'_'+String(layer_lst.length)}</p></div>`));

                        id_lst.push(raster._leaflet_id);

                        // custom info box

                        var info = L.control({position: "bottomright"});

                        info.onAdd = function (map) {
                            this._div = L.DomUtil.create('div', 'info'); // create a div with a class "info"
                            this._div.innerHTML = `<h4>Mean Areal Precipitation</h4><p style='color:black;'>Overall sum:${raster_stats.sum}</p>
                            <p style='color:black;'>Overall mean:${raster_stats.mean}</p>`;
                            return this._div;
                        };

                        if (added_info==0){
                            info.addTo(map);
                            added_info++;
                        } else {
                            info_lst[id_lst[added_info-1]].remove();
                            info.addTo(map);
                            added_info++;
                        }

                        info_lst[raster._leaflet_id] = info;

                        // set up legend

                        legend = L.control({position: 'bottomleft'});

                        legend.onAdd = function (map) {

                            var div = L.DomUtil.create('div', 'legend');

                            // loop through our density intervals and generate a label with a colored square for each interval
                            for (var i = raster_range[0]; i < raster_range[1]; i += partition) {
                                div.innerHTML +=
                                    '<div style="display: flex; flex-direction: row;"><i style="background:' + getColor((i + partition)) + '"></i>' +
                                    '<p class="legend_element">' +i + (i<(raster_range[1]-partition) ? '&ndash;' + (i+partition) : '+') + '</p>' + '</div>';
                            }

                            return div;
                        };

                        if (added_legend==0){
                            legend.addTo(map);
                            added_legend++;
                        } else {
                            legend_lst[id_lst[added_legend-1]].remove();
                            legend.addTo(map);
                            added_legend++;
                        }

                        legend_lst[raster._leaflet_id] = legend;

                    }
                    console.log(id_lst);
                    console.log(legend_lst);
                    console.log(info_lst);
                    
                }
                */
            }   
        });
        $( "#dragg" ).disableSelection();
    } );

});
    </script>
</head>

<body>
    <div id="main_container">
        <div id="map_header">
            <div id="mobile_menu">
                <i class="fa fa-bars mobile_menu_icon"></i>
            </div>
            <div id="left_header">
                <h3><a href="{{ url_for('home') }}" id="home_ref">Home</a></h3>
            </div>
            <div id="mid_header">
                <h1>Monitoring Toolbox</h1>
            </div>
            <div id="right_header">
                <a href="https://www.digitalearth-hgf.de/de" target="_blank"><img src="../static/resources/logo.png" id="de_logo"></a>
            </div>
        </div>
        <div id="my-map"></div>
        <div class="controls">
            <div id="button_container">
                <button class="expand_btn"><i class="fa fa-angle-double-down show_i"></i></button>
            </div>
            <div id="input_container">
                <ul id="btn_group">
                    <button id="map_btn">Map</button>
                    <button id="inset_btn">Inset</button>
                </ul>
                <div id="form_post_map">
                        <p class="input_label" style="margin-top: 20px;">Dataset</p>
                        <div class="selectBox" id="map_input_dataset">
                          <span class="selected"></span>
                          <span class="selectArrow"><i class="fa fa-chevron-down" style="padding-left: 10px; font-size: 11px;"></i></span>
                          <div class="selectOptions">
                            <div class="selectGroupOption">
                                <div class="heading">
                                    <span class="groupOption">Shapefile</span>
                                    <span class="selectBtn">+</span>
                                </div>
                                <div class="selectOption">dataset_a</div>
                            </div>
                            <div class="selectGroupOption">
                                <div class="heading">
                                    <span class="groupOption">Raster</span>
                                    <span class="selectBtn">+</span>
                                </div>
                                <div class="selectOption">dataset_b</div>
                                <div class="selectOption">dataset_c</div>
                            </div>
                          </div>
                        </div>
                        <p class="input_label">Variable</p>
                        <select class="inputs" id="variable_input_map">
                        </select>
                        <p class="input_label" id="time_input_map_label">Time Variable</p>
                        <select class="inputs" id="time_input_map">
                        </select>
                        <div id="animation_play"><i class="fa fa-play" style="color: white;"></i></div>
                        <p class="input_label">Filter</p>
                        <input type="text" class="inputs" id="map_input_filter_operator">
                        <p class="input_label">Calculation</p>
                        <input type="text" class="inputs" id="map_input_calc_operator">
                        <p class="input_label">Color Palette</p>
                        <div class="selectBox" id="map_input_palette">
                          <span class="selectedPalette"></span>
                          <span class="selectArrow"><i class="fa fa-chevron-down" style="padding-left: 10px; padding-right: 10px; font-size: 11px;"></i></span>
                          <div class="selectOptions" id="selectOptionsPalette">
                                <div class="selectOption viridis selectOptionPalette"></div>
                                <div class="selectOption magma selectOptionPalette"></div>
                                <div class="selectOption blues selectOptionPalette"></div>
                                <div class="selectOption reds selectOptionPalette"></div>
                          </div>
                        </div>    
                        <p class="input_label">Value Extraction</p>
                        <select class="inputs" style="margin-bottom: 20px;" id="map_input_extraction">
                            <option value="none">None</option>
                            <option value="single">Single</option>
                            <option value="sum">Sum</option>
                            <option value="mean">Mean</option>
                        </select>
                        <div id="value_output"></div>
                        <div id="download"><i class="fa fa-download" style="color: white;"></i></div>
                        <div style="text-align: center;"><button class="inputs submit" id="submit_btn_map">Apply</button></div>
                </div>
                <div id="form_post_inset">
                    <p class="input_label" style="margin-top: 20px;">Dataset</p>
                    <div class="selectBox" id="inset_input_dataset">
                      <span class="selected"></span>
                      <span class="selectArrow"><i class="fa fa-chevron-down" style="padding-left: 10px; font-size: 11px;"></i></span>
                      <div class="selectOptions">
                        <div class="selectGroupOption">
                            <div class="heading">
                                <span class="groupOption">Shapefiles</span>
                                <span class="selectBtn">+</span>
                            </div>
                            <div class="selectOption">dataset_a</div>
                        </div>
                        <div class="selectGroupOption">
                            <div class="heading">
                                <span class="groupOption">Raster</span>
                                <span class="selectBtn">+</span>
                            </div>
                            <div class="selectOption">dataset_b</div>
                            <div class="selectOption">dataset_c</div>
                        </div>
                      </div>
                    </div>
                    <p class="input_label">Variable</p>
                    <select class="inputs" id="variable_input_inset">
                    </select>
                    <p class="input_label">Start Date</p>
                    <input type="date" id="inset_input_start_date" value="2000-01-01" min="1900-01-01" max="2021-07-08" class="inputs">
                    <p class="input_label">End Date</p>
                    <input type="date" id="inset_input_end_date" value="2000-01-01" min="1900-01-01" max="2021-07-08" class="inputs">
                    <div style="text-align: center;"><button class="inputs submit" id="submit_btn_inset">Apply</button></div>
                    <div id="mobile_inset"></div>
                </div>
            </div>
        </div>
        <div class="inset" style="text-align: center;">
                <div id="plotly"></div>
        </div>
        <div class="toast"><b style="padding-top: 10px;">Warning:</b><br><p id="error_text"></p></div>
        <div class="loader"></div>
        <div class="tree" id="dragg"></div>
        <div class="mobile_menu_bar">
            <a href="{{ url_for('home') }}">Home</a>
            <a href="https://www.digitalearth-hgf.de/de" target="_blank">Digital Earth Homepage</a>
        </div>
        <div class="animation_control">
            <div id="progress"><div id="bar"></div></div>
            <i class="fa fa-backward previous" style="color: white; grid-area: previous"></i>
            <i class="fa fa-pause stop_animation" style="color: white; grid-area: play"></i>
            <i class="fa fa-forward next" style="color: white; grid-area: next"></i>
            <i class="fa fa-pause replay" style="color: white; grid-area: replay"></i>
            <div id="time" style="grid-area: time; color: white;"></div>
        </div>
        <button id="test"></button>
        <div class="exit_bar">
            <p>Data sets to Download</p>
            <i class="fa fa-times-circle"></i>
            </div>
        <div class="download_control">
            <button class='submit_download'>Download</button>
        </div>
    </div>
</body>
</html>
